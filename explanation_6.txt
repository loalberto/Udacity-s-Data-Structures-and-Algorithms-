Union and Intersection:
In this problem I used while loops to help me traverse each linked list. What I did for union was first take the elements of the first list and transfer them into the new union list. While getting ride of any duplicates. I checked if a node in the first list was already present in the union_list and if it was then I skiped it. Else, I added it. Then for the second list I did the same thing but with the union_list already having the first list in it. It again, removed any duplicates and only added new elements.
For Intersection, I took both lists and when a node shared the same value with the other list I checked if that node was already present in my inter_list. If it was already there then I skipped it and if it wasn't then I added it. This also, got rid of any duplicates. The union operation will have a time complexity of O(n^2), where n is the number of elements in the lists. It could be that all elements in list1 and list are unique so I will check for each element and see if it already exists in the union_list. For intersection it gets as bad as O(n^3) where I every single element can be a match and so for each element I would check if it exists in the inter_list. This only stores at most 3 linked lists and so its space complexity is O(n). The longest list, the union list, can contain up to n + m nodes, where n is the number of nodes in list1 and m is the number of elements in list2. The choice of data structure was another linked list to be able to keep track of the new union list and the intersection list. 