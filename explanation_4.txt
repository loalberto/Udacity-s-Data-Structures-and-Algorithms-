Huffman Encoding:
What I did for the enconding was take the original data and split it into single characters of the string, then I sorted them based on their frequency. Then I created each key and value into a node. Each node was then stored in a Queue. I figured that using a queue implementation worked best because I my implementation followed a First in First Out basis. Then I grouped the first two Nodes and gave it an internal node. I kept doing this until I only had the root of the tree or the None sentinal value left. If I ran into a left child having None then I would append it the back of the queue. If I ran into a right child having a None value then I put both the left child and the right child into the back of the queue. Once I built the tree, I was then able to use recursion to set its designated ones and zeros. Zero for the left child and one for the right child. After those were set, I then traversed the tree, until I reached a leaf, and recorded each leaf's code into a dictionary. I then broke the data into single characters again and checked for its code in the dictionary. Then I returned the new compressed values and the root of the tree. Decoding was made through checking each number in the compressed value and seeing if I found a match in my dictionary. Once I found a match I joined the string together to be able to get the original value. This one's time complexity is O(nlogn) since I am using a built-in sorting function to be able to sort the frequencies. But the time to build a tree will take O(n), since it will have to check n number of elements but, if I can be specific then it is accurate to say that it reaches 2*n because of the process of building a tree. I have n elements + n-1 internal nodes. So it will have a time complexity of O(n). Spliting the data into single characters and storing their codes and checking for a letters code are all O(n). This implementation has a space complexity of O(n) because it will need to store a tree that contains 2*n number of nodes and will also store information in a Queue to be able to build the internal nodes. It will also have to store all the letter's codes in a dictionary. All are a linear amount of storage. The choice of a data structure included a Queue and a Binary Tree because the queue helped me build a binary tree's internal nodes. The huffman coding that I created used a binary tree implementation.